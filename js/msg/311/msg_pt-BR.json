{

	"btprevious" : "Anterior",
	"btnext" : "Próximo",

	"PiL1" : "JAX-RS: Java™ API para RESTful",
	"PiL2" : "Web Services",
	"PiL3" : "Versão 1.0",
	"PiL4" : "8 de Setembro de 2008",
	"PiL5" : "Editores:",
	"PiL6" : "Marc Hadley",
	"PiL7" : "Paul Sandoz",
	"PiL8" : "Comentários para: users@jsr311.dev.java.net",
	"PiL9" : "Sun Microsystems, Inc.",
	"PiL10" : "4150 Network Circle, Santa Clara, CA 95054 USA.",
	"PiL11" : "180, Avenue de L’Europe, 38330 Montbonnot Saint Martin, France",

	"PiiiL1" : "Especificação: JSR-000311 - Java™ API for RESTful Web Services (“Specification”)",
	"PiiiL2" : "Versão: 1.0",
	"PiiiL3" : "Status: Versão Final",
	"PiiiL4" : "Release: 8 de Setembro de 2008",
	"PiiiL5" : "Copyright 2007 Sun Microsystems, Inc.",
	"PiiiL6" : "4150 Network Circle, Santa Clara, California 95054, U.S.A",
	"PiiiL7" : "180, Avenue de L’Europe, 38330 Montbonnot Saint Martin, France",
	"PiiiL8" : "Todos os direitos reservados.",
	"PiiiL9" : "CONCESSÕES DE LICENÇA LIMITADA",
	"PiiiL10" : "License for Evaluation Purposes. Sun hereby grants you a fully-paid, non-exclusive, non-transferable, worldwide, limited license (without the right to sublicense), under Sun’s applicable intellectual property rights to view, download, use and reproduce the Specification only for the purpose of internal evaluation. This includes (i) developing applications intended to run on an implementation of the Specification, provided that such applications do not themselves implement any portion(s) of the Specification, and (ii) discussing the Specification with any third party; and (iii) excerpting brief portions of the Specification in oral or written communications which discuss the Specification provided that such excerpts do not in the aggregate constitute a significant portion of the Specification.",
	"PiiiL11" : "License for the Distribution of Compliant Implementations. Sun also grants you a perpetual, non-exclusive, non-transferable, worldwide, fully paid-up, royalty free, limited license (without the right to sublicense) under any applicable copyrights or, subject to the provisions of subsection 4 below, patent rights it may have covering the Specification to create and/or distribute an Independent Implementation of the Specification that: (a) fully implements the Specification including all its required interfaces and functionality; (b) does not modify, subset, superset or otherwise extend the Licensor Name Space, or include any public or protected packages, classes, Java interfaces, fields or methods within the Licensor Name Space other than those required/authorized by the Specification or Specifications being implemented; and (c) passes the Technology Compatibility Kit (including satisfying the requirements of the applicable TCK Users Guide) for such Specification (“Compliant Implementation”). In addition, the foregoing license is expressly conditioned on your not acting outside its scope. No license is granted hereunder for any other purpose (including, for example, modifying the Specification, other than to the extent of your fair use rights, or distributing the Specification to third parties). Also, no right, title, or interest in or to any trademarks, service marks, or trade names of Sun or Sun’s licensors is granted hereunder. Java, and Java-related logos, marks and names are trademarks or registered trademarks of Sun Microsystems, Inc. in the U.S. and other countries.",
	"PiiiL12" : "Pass-through Conditions. You need not include limitations (a)-(c) from the previous paragraph or any other particular “pass through” requirements in any license You grant concerning the use of your Independent Implementation or products derived from it. However, except with respect to Independent Implementations (and products derived from them) that satisfy limitations (a)-(c) from the previous paragraph, You may neither: (a) grant or otherwise pass through to your licensees any licenses under Sun’s applicable intellectual property rights; nor (b) authorize your licensees to make any claims concerning their implementation’s compliance with the Specification in question.",
	"PiiiL13" : "Reciprocity Concerning Patent Licenses.",
	"PiiiL14" : "With respect to any patent claims covered by the license granted under subparagraph 2 above that would be infringed by all technically feasible implementations of the Specification, such license is conditioned upon your offering on fair, reasonable and non-discriminatory terms, to any party seeking it from You, a perpetual, non-exclusive, non-transferable, worldwide license under Your patent rights which are or would be infringed by all technically feasible implementations of the Specification to develop, distribute and use a Compliant Implementation.",
	"PiiiL15" : "With respect to any patent claims owned by Sun and covered by the license granted under subparagraph 2, whether or not their infringement can be avoided in a technically feasible manner when implementing the Specification, such license shall terminate with respect to such claims if You initiate a claim against Sun that it has, in the course of performing its responsibilities as the Specification Lead, induced any other entity to infringe Your patent rights.",
	"PiiiL16" : "Also with respect to any patent claims owned by Sun and covered by the license granted under subparagraph 2 above, where the infringement of such claims can be avoided in a technically feasible manner when implementing the Specification such license, with respect to such claims, shall terminate if You initiate a claim against Sun that its making, having made, using, offering to sell, selling or importing a Compliant Implementation infringes Your patent rights.",
	"PiiiL17" : "Definitions. For the purposes of this Agreement: “Independent Implementation” shall mean an implementation of the Specification that neither derives from any of Sun’s source code or binary code materials nor, except with an appropriate and separate license from Sun, includes any of Sun’s source code or binary code materials; “Licensor Name Space” shall mean the public class or interface declarations whose names begin with “java”, “javax”, “com.sun” or their equivalents in any subsequent naming convention adopted by Sun through the Java Community Process, or any recognized successors or replacements thereof; and “Technology Compatibility Kit” or “TCK” shall mean the test suite and accompanying TCK User’s Guide provided by Sun which corresponds to the Specification and that was available either (i) from Sun’s 120 days before the first release of Your Independent Implementation that allows its use for commercial purposes, or (ii) more recently than 120 days from such release but against which You elect to test Your implementation of the Specification.",

	"PivL1" : "This Agreement will terminate immediately without notice from Sun if you breach the Agreement or act outside the scope of the licenses granted above.",
	"PivL2" : "MARCAS",
	"PivL3" : "No right, title, or interest in or to any trademarks, service marks, or trade names of Sun or Sun’s licensors is granted hereunder. Sun, Sun Microsystems, the Sun logo, Java, are trademarks or registered trademarks of Sun Microsystems, Inc. in the U.S. and other countries.",
	"PivL4" : "DISCLAIMER OF WARRANTIES",
	"PivL5" : "THE SPECIFICATION IS PROVIDED “AS IS”. SUN MAKES NO REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT (INCLUDING AS A CONSEQUENCE OF ANY PRACTICE OR IMPLEMENTATION OF THE SPECIFICATION), OR THAT THE CONTENTS OF THE SPECIFICATION ARE SUITABLE FOR ANY PURPOSE. This document does not represent any commitment to release or implement any portion of the Specification in any product. In addition, the Specification could include technical inaccuracies or typographical errors.",
	"PivL6" : "LIMITATION OF LIABILITY",
	"PivL7" : "TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION, LOST REVENUE, PROFITS OR DATA, OR FOR SPECIAL, INDIRECT, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF OR RELATED IN ANY WAY TO YOUR HAVING, IMPELEMENTING OR OTHERWISE USING USING THE SPECIFICATION, EVEN IF SUN AND/OR ITS LICENSORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.",
	"PivL8" : "You will indemnify, hold harmless, and defend Sun and its licensors from any claims arising or resulting from: (i) your use of the Specification; (ii) the use or distribution of your Java application, applet and/or implementation; and/or (iii) any claims that later versions or releases of any Specification furnished to you are incompatible with the Specification provided to you under this license.",
	"PivL9" : "RESTRICTED RIGHTS LEGEND",
	"PivL10" : "U.S. Government: If this Specification is being acquired by or on behalf of the U.S. Government or by a U.S. Government prime contractor or subcontractor (at any tier), then the Government’s rights in the Software and accompanying documentation shall be only as set forth in this license; this is in accordance with 48 C.F.R. 227.7201 through 227.7202-4 (for Department of Defense (DoD) acquisitions) and with 48 C.F.R. 2.101 and 12.212 (for non-DoD acquisitions).",
	"PivL11" : "INFORME",
	"PivL12" : "If you provide Sun with any comments or suggestions concerning the Specification (“Feedback”), you hereby: (i) agree that such Feedback is provided on a non-proprietary and non-confidential basis, and (ii) grant Sun a perpetual, non-exclusive, worldwide, fully paid-up, irrevocable license, with the right to sublicense through multiple levels of sublicensees, to incorporate, disclose, and use without limitation the Feedback for any purpose.",
	"PivL13" : "TERMOS GERAIS",
	"PivL14" : "Any action related to this Agreement will be governed by California law and controlling U.S. federal law. The U.N. Convention for the International Sale of Goods and the choice of law rules of any jurisdiction will not apply.",
	"PivL15" : "The Specification is subject to U.S. export control laws and may be subject to export or import regulations in other countries. Licensee agrees to comply strictly with all such laws and regulations and acknowledges that it has the responsibility to obtain such licenses to export, re-export or import as may be required after delivery to Licensee.",
	"PivL16" : "This Agreement is the parties’ entire agreement relating to its subject matter. It supersedes all prior or contemporaneous oral or written communications, proposals, conditions, representations and warranties and prevails over any conflicting or additional terms of any quote, order, acknowledgment, or other communication between the parties relating to its subject matter during the term of this Agreement. No modification to this Agreement will be binding, unless in writing and signed by an authorized representative of each party.",
	"PivL17" : "Rev. Abril, 2006",

	"PviiL1" : "Introdução",
	"PviiL2" : "Status",
	"PviiL3" : "Goals",
	"PviiL4" : "Non-Goals",
	"PviiL5" : "Convenções",
	"PviiL6" : "Terminolodia",
	"PviiL7" : "Expert Group Members",
	"PviiL8" : "Agradecimentos",
	"PviiL9" : "Aplicações",
	"PviiL10" : "Configuração",
	"PviiL11" : "Validação",
	"PviiL12" : "Publicação",
	"PviiL13" : "Java SE",
	"PviiL14" : "Servlet",
	"PviiL15" : "Outro Container",
	"PviiL16" : "Resources",
	"PviiL17" : "Resource Classes",
	"PviiL18" : "Ciclo de vida e Ambiente",
	"PviiL19" : "Construtores",
	"PviiL20" : "Campos e Propriedades de Bean",
	"PviiL21" : "Resource Methods",
	"PviiL22" : "Visibilidade",
	"PviiL23" : "Parametros",
	"PviiL24" : "Tipo de Retorno",
	"PviiL25" : "Exceções",
	"PviiL26" : "HEAD e OPTIONS",
	"PviiL27" : "URI Templates",
	"PviiL28" : "Sub Resources",
	"PviiL29" : "Declaring Media Type Capabilities",
	"PviiL30" : "Annotation Inheritance",
	"PviiL31" : "Matching Requests to Resource Methods",
	"PviiL32" : "Request Preprocessing",
	"PviiL33" : "Request Matching",
	"PviiL34" : "Converting URI Templates to Regular Expressions",
	"PviiL35" : "Determining the MediaType of Responses",
	"PviiL36" : "Providers",
	"PviiL37" : "Ciclo de vida e Ambiente",
	"PviiL38" : "Construtores",
	"PviiL39" : "Entity Providers",
	"PviiL40" : "Message Body Reader",
	"PviiL41" : "Message Body Writer",
	"PviiL42" : "Declaring Media Type Capabilities",
	"PviiL43" : "Standard Entity Providers",
	"PviiL44" : "Transfer Encoding",
	"PviiL45" : "Content Encoding",
	"PviiL46" : "Context Providers",
	"PviiL47" : "Declaring Media Type Capabilities",
	"PviiL48" : "Exception Mapping Providers",
	"PviiL49" : "Context",
	"PviiL50" : "Concurrency",
	"PviiL51" : "Tipos de Contexto",
	"PviiL52" : "URIs e URI Templates",
	"PviiL53" : "Headers",
	"PviiL54" : "Content Negotiation and Preconditions",
	"PviiL55" : "Security Context",
	"PviiL56" : "Providers",
	"PviiL57" : "Ambiente",
	"PviiL58" : "Servlet Container",
	"PviiL59" : "Java EE Container (Non-normative)",
	"PviiL60" : "Outro",
	"PviiL61" : "Runtime Delegate",
	"PviiL62" : "Configuração",
	"PviiL63" : "Anotações do Sumário",
	"PviiL64" : "HTTP Header Support",
	"PviiL65" : "Change Log",
	"PviiL66" : "Changes Since Proposed Final Draft",
	"PviiL67" : "Changes Since Public Review Draft",
	"PviiL68" : "Bibliografia",

	"P1L1" : "Capítulo 1",
	"P1L2" : "Introdução",
	"P1L3" : "This specification defines a set of Java APIs for the development of Web services built according to the Representational State Transfer[1] (REST) architectural style. Readers are assumed to be familiar with REST; for more information about the REST architectural style and RESTful Web services, see:",
	"P1L4" : "Architectural Styles and the Design of Network-based Software Architectures[1]",
	"P1L5" : "The REST Wiki[2]",
	"P1L6" : "Representational State Transfer on Wikipedia[3]",
	"P1L7" : "1.1 Status",
	"P1L8" : "This is an editors draft; this specification is not yet complete. A list of open issues can be found at: https://jsr311.dev.java.net/servlets/ProjectIssues",
	"P1L9" : "The latest Javadocs can be found online at: https://jsr311.dev.java.net/nonav/javadoc/index.html",
	"P1L10" : "The reference implementation can be obtained from: https://jersey.dev.java.net/",
	"P1L11" : "The expert group seeks feedback from the community on any aspect of this specification, please send comments to: users@jsr311.dev.java.net",
	"P1L18" : "1.2 Goals",
	"P1L19" : "The following are the goals of the API:",
	"P1L20" : "POJO-based The API will provide a set of annotations and associated classes/interfaces that may be used with POJOs in order to expose them as Web resources. The specification will define object lifecycle and scope.",
	"P1L21" : "HTTP-centric The specification will assume HTTP[4] is the underlying network protocol and will provide a clear mapping between HTTP and URI[5] elements and the corresponding API classes and annotations. The API will provide high level support for common HTTP usage patterns and will be sufficiently flexible to support a variety of HTTP applications including WebDAV[6] and the Atom Publishing Protocol[7].",
	"P1L22" : "Format independence The API will be applicable to a wide variety of HTTP entity body content types. It will provide the necessary pluggability to allow additional types to be added by an application in a standard manner",
	"P1L23" : "Container independence Artifacts using the API will be deployable in a variety of Web-tier containers. The specification will define how artifacts are deployed in a Servlet[8] container and as a JAX-WS[9] Provider.",
	"P1L24" : "Inclusion in Java EE The specification will define the environment for a Web resource class hosted in a Java EE container and will specify how to use Java EE features and components within a Web resource class.",
	"P1L25" : "1.3 Non-Goals",
	"P1L26" : "The following are non-goals:",
	"P1L27" : "Support for Java versions prior to J2SE 5.0 The API will make extensive use of annotations and will require J2SE 5.0 or later.",
	"P1L28" : "Description, registration and discovery The specification will neither define nor require any service description, registration or discovery capability.",
	"P1L29" : "Client APIs The specification will not define client-side APIs. Other specifications are expected to provide such functionality.",
	"P1L30" : "HTTP Stack The specification will not define a new HTTP stack. HTTP protocol support is provided by a container that hosts artifacts developed using the API.",
	"P1L31" : "Data model/format classes The API will not define classes that support manipulation of entity body content, rather it will provide pluggability to allow such classes to be used by artifacts developed using the API.",
	"P1L32" : "1.4 Conveções",
	"P1L33" : "The keywords ‘MUST’, ‘MUST NOT’, ‘REQUIRED’, ‘SHALL’, ‘SHALL NOT’, ‘SHOULD’, ‘SHOULD NOT’, ‘RECOMMENDED’, ‘MAY’, and ‘OPTIONAL’ in this document are to be interpreted as described in RFC 2119[10].",
	"P1L34" : "Java code and sample data fragments are formatted as shown in figure 1.1:",
	"P1L35" : "Figura 1.1: Examplo de Código Java",
	"P1L36" : "URIs of the general form ‘http://example.org/...’ and ‘http://example.com/...’ represent application or context-dependent URIs.",
	"P1L37" : "All parts of this specification are normative, with the exception of examples, notes and sections explicitly marked as ‘Non-Normative’. Non-normative notes are formatted as shown below",
	"P1L38" : "Nota: Esta é uma nota.",
	"P1L39" : "1.5 Terminologia",
	"P1L40" : "Resource class A Java class that uses JAX-RS annotations to implement a corresponding Web resource, see chapter 3.",
	"P1L41" : "Root resource class A resource class annotated with @Path. Root resource classes provide the roots of the resource class tree and provide access to sub-resources, see chapter 3.",
	"P1L41" : "Request method designator A runtime annotation annotated with @HttpMethod. Used to identify the HTTP request method to be handled by a resource method",
	"P1L42" : "Resource method A method of a resource class annotated with a request method designator that is used to handle requests on the corresponding resource, see section 3.3.",
	"P1L43" : "Sub-resource locator A method of a resource class that is used to locate sub-resources of the corresponding resource, see section 3.4.1. ",
	"P1L44" : "Sub-resource method A method of a resource class that is used to handle requests on a sub-resource of the corresponding resource, see section 3.4.1. ",
	"P1L45" : "Provider An implementation of a JAX-RS extension interface. Providers extend the capabilities of a JAX-RS runtime and are described in chapter 4.",
	"P1L46" : "1.6 Expert Group Members",
	"P1L47" : "This specification is being developed as part of JSR 311 under the Java Community Process. This specification is the result of the collaborative work of the members of the JSR 311 Expert Group. The following are the present and former expert group members:",
	"P1L48" : "Jan Algermissen (Individual Member)",
	"P1L49" : "Heiko Braun (Red Hat Middleware LLC)",
	"P1L50" : "Bill Burke (Red Hat Middleware LLC)",
	"P1L51" : "Larry Cable (BEA Systems)",
	"P1L52" : "Bill De Hora (Individual Member)",
	"P1L53" : "Roy Fielding (Day Software, Inc.)",
	"P1L54" : "Harpreet Geekee (Nortel)",
	"P1L55" : "Nickolas Grabovas (Individual Member)",
	"P1L56" : "Mark Hansen (Individual Member)",
	"P1L57" : "John Harby (Individual Member)",
	"P1L58" : "Hao He (Individual Member)",
	"P1L59" : "Ryan Heaton (Individual Member)",
	"P1L60" : "David Hensley (Individual Member)",
	"P1L61" : "Stephan Koops (Individual Member)",
	"P1L62" : "Changshin Lee (NCsoft Corporation)",
	"P1L63" : "Francois Leygues (Alcatel-Lucent)",
	"P1L64" : "Jerome Louvel (Individual Member)",
	"P1L65" : "Hamid Ben Malek (Fujitsu Limited)",
	"P1L66" : "Ryan J. McDonough (Individual Member)",
	"P1L67" : "Felix Meschberger (Day Software, Inc.)",
	"P1L68" : "David Orchard (BEA Systems)",
	"P1L69" : "Dhanji R. Prasanna (Individual Member)",
	"P1L70" : "Julian Reschke (Individual Member)",
	"P1L71" : "Jan Schulz-Hofen (Individual Member)",
	"P1L72" : "Joel Smith (IBM)",
	"P1L73" : "Stefan Tilkov (innoQ Deutschland GmbH)",
	"P1L74" : "1.7 Agradecimentos",
	"P1L75" : "During the course of the JSR we received many excellent suggestions on the JSR and Jersey (RI) mailing lists, thanks in particular to James Manger (Telstra) and Reto Bachmann-Gmur (Trialox) for their contributions.",
	"P1L76" : "The GenericEntity class was inspired by the Google Guice TypeLiteral class. Our thanks to Bob Lee and Google for donating this class to JAX-RS. ",
	"P1L77" : "The following individuals (all Sun Microsystems) have also made invaluable technical contributions: Roberto Chinnici, Dianne Jiao (TCK), Ron Monzillo, Rajiv Mordani, Eduardo Pelegri-Llopart, Jakub Podlesak (RI) and Bill Shannon.",

	"P2L1" : "Capítulo 2",
	"P2L2" : "Aplicações",
	"P2L3" : "A JAX-RS application consists of one or more resources (see chapter 3) and zero or more providers (see chapter 4). This chapter describes aspects of JAX-RS that apply to an application as a whole, subsequent chapters describe particular aspects of a JAX-RS application and requirements on JAX-RS implementations.",
	"P2L4" : "2.1 Configuração",
	"P2L5" : "The resources and providers that make up a JAX-RS application are configured via an application-supplied subclass of Application. An implementation MAY provide alternate mechanisms for locating resource classes and providers (e.g. runtime class scanning) but use of Application is the only portable means of configuration.",
	"P2L6" : "2.2 Validação",
	"P2L7" : "Specific validation requirements are detailed throughout this specification and the JAX-RS Javadocs. Implementations MAY perform additional validation where feasible and SHOULD report any issues arising from such validation to the user. ",
	"P2L8" : "2.3 Publicação",
	"P2L9" : "Applications are published in different ways depending on whether the application is run in a Java SE environment or within a container. This section describes the alternate means of publication.",
	"P2L10" : "2.3.1 Java SE",
	"P2L11" : "In a Java SE environment a configured instance of an endpoint class can be obtained using the create-Endpoint method of RuntimeDelegate. The application supplies an instance of Application and the type of endpoint required. An implementation MAY support zero or more endpoint types of any desired type.",
	"P2L12" : "How the resulting endpoint class instance is used to publish the application is outside the scope of this specification. ",
	"P2L13" : "2.3.1.1 JAX-WS",
	"P2L14" : "An implementation that supports publication via JAX-WS MUST support createEndpoint with an end-point type of javax.xml.ws.Provider. JAX-WS describes how a Provider based endpoint can be published in an SE environment.",
	"P2L15" : "2.3.2 Servlet",
	"P2L16" : "A JAX-RS application is packaged as a Servlet in a .war file. The Application subclass (see section 2.1), resource classes, and providers are packaged in WEB-INF/classes, required libraries are packaged in WEB-INF/lib. Included libraries MAY also contain resource classes and providers as desired. See the Servlet specification for full details on packaging of web applications. ",
	"P2L17" : "When using a JAX-RS aware servlet container, the servlet-class element of the web.xml descriptor SHOULD name the application-supplied subclass of Application.",
	"P2L18" : "When using a non-JAX-RS aware servlet container, the servlet-class element of the web.xml descriptor SHOULD name the JAX-RS implementation-supplied Servlet class. The application-supplied subclass of Application is identified using an init-param with a param-name of javax.ws.rs.Application.",
	"P2L19" : "2.3.3 Other Container",
	"P2L20" : "An implementation MAY provide facilities to host a JAX-RS application in other types of container, such facilities are outside the scope of this specification. ",

	"P3L1" : "Capítulo 3",
	"P3L2" : "Resources",
	"P3L3" : "Using JAX-RS a Web resource is implemented as a resource class and requests are handled by resource methods. This chapter describes resource classes and resource methods in detail.",
	"P3L4" : "3.1 Resource Classes",
	"P3L5" : "A resource class is a Java class that uses JAX-RS annotations to implement a corresponding Web resource. Resource classes are POJOs that have at least one method annotated with @Path or a request method designator.",
	"P3L6" : "3.1.1 Lifecycle and Environment",
	"P3L7" : "By default a new resource class instance is created for each request to that resource. First the constructor (see section 3.1.2) is called, then any requested dependencies are injected (see section 3.2), then the appropriate method (see section 3.3) is invoked and finally the object is made available for garbage collection. ",
	"P3L8" : "An implementation MAY offer other resource class lifecycles, mechanisms for specifying these are outside the scope of this specification. E.g. an implementation based on an inversion-of-control framework may support all of the lifecycle options provided by that framework.",
	"P3L9" : "3.1.2 Construtores",
	"P3L10" : "Root resource classes are instantiated by the JAX-RS runtime and MUST have a public constructor for which the JAX-RS runtime can provide all parameter values. Note that a zero argument constructor is permissible under this rule. ",
	"P3L11" : "A public constructor MAY include parameters annotated with one of the following: @Context, @HeaderParam, @CookieParam, @MatrixParam, @QueryParam or @PathParam. However, depending on the resource class lifecycle and concurrency, per-request information may not make sense in a constructor. If more than one public constructor is suitable then an implementation MUST use the one with the most parameters. Choosing amongst suitable constructors with the same number of parameters is implementation specific, implementations SHOULD generate a warning about such ambiguity. ",
	"P3L12" : "Non-root resource classes are instantiated by an application and do not require the above-described public constructor. ",
	"P3L13" : "3.2 Campos e Propriedades de Bean",
	"P3L14" : "When a resource class is instantiated, the values of fields and bean properties annotated with one the following annotations are set according to the semantics of the annotation: ",
	"P3L15" : "@MatrixParam Extracts the value of a URI matrix parameter.",
	"P3L16" : "@QueryParam Extracts the value of a URI query parameter.",
	"P3L17" : "@PathParam Extracts the value of a URI template parameter.",
	"P3L18" : "@CookieParam Extracts the value of a cookie.",
	"P3L19" : "@HeaderParam Extracts the value of a header.",
	"P3L20" : "@Context Injects an instance of a supported resource, see chapters 5 and 6 for more details.",
	"P3L21" : "Because injection occurs at object creation time, use of these annotations (with the exception of @Context) on resource class fields and bean properties is only supported for the default per-request resource class lifecycle. An implementation SHOULD warn if resource classes with other lifecycles use these annotations on resource class fields or bean properties.",
	"P3L22" : "An implementation is only required to set the annotated field and bean property values of instances created by the implementation runtime. Objects returned by sub-resource locators (see section 3.4.1) are expected to be initialized by their creator and field and bean properties are not modified by the implementation runtime.",
	"P3L23" : "Valid parameter types for each of the above annotations are listed in the corresponding Javadoc, however in general (excluding @Context) the following types are supported:",
	"P3L24" : "Primitive types",
	"P3L25" : "Types that have a constructor that accepts a single String argument",
	"P3L26" : "Types that have a static method named valueOf with a single String argument",
	"P3L27" : "List<T>, Set<T>, or SortedSet<T>, where T satisfies 2 or 3 above.",
	"P3L28" : "The DefaultValue annotation may be used to supply a default value for some of the above, see the Javadoc for DefaultValue for usage details and rules for generating a value in the absence of this annotation and the requested data. The Encoded annotation may be used to disable automatic URI decoding for @MatrixParam, @QueryParam, and @PathParam annotated fields and properties. ",
	"P3L29" : "A WebApplicationException thrown during construction of field or property values using 2 or 3 above is processed directly as described in section 3.3.4. Other exceptions thrown during construction of field or property values using 2 or 3 above are treated as client errors: if the field or property is annotated with @MatrixParam, @QueryParam or @PathParam then an implementation MUST generate a WebApplicationException that wraps the thrown exception with a not found response (404 status) and no entity; if the field or property is annotated with @HeaderParam or @CookieParam then an implementation MUST generate a WebApplicationException that wraps the thrown exception with a client error response (400 status) and no entity. The WebApplicationException MUST be then be processed as described in section 3.3.4.",
	"P3L30" : "3.3 Resource Methods",
	"P3L31" : "Resource methods are methods of a resource class annotated with a request method designator. They are used to handle requests and MUST conform to certain restrictions described in this section.",
	"P3L32" : "A request method designator is a runtime annotation that is annotated with the @HttpMethod annotation. JAX-RS defines a set of request method designators for the common HTTP methods: @GET, @POST, @PUT, @DELETE, @HEAD. Users may define their own custom request method designators including alternate designators for the common HTTP methods. ",
	"P3L33" : "3.3.1 Visibilidade",
	"P3L34" : "Only public methods may be exposed as resource methods. An implementation SHOULD warn users if a non-public method carries a method designator or @Path annotation.",
	"P3L35" : "3.3.2 Parametros",
	"P3L36" : "When a resource method is invoked, parameters annotated with @FormParam or one of the annotations listed in section 3.2 are mapped from the request according to the semantics of the annotation. Similar to fields and bean properties: ",
	"P3L37" : "The DefaultValue annotation may be used to supply a default value for parameters",
	"P3L38" : "The Encoded annotation may be used to disable automatic URI decoding of parameter values",
	"P3L39" : "Exceptions thrown during construction of parameter values are treated the same as exceptions thrown during construction of field or bean property values, see section 3.2.",
	"P3L40" : "3.3.2.1 Entity Parameters",
	"P3L41" : "The value of a non-annotated parameter, called the entity parameter, is mapped from the request entity body. Conversion between an entity body and a Java type is the responsibility of an entity provider, see section 4.2. ",
	"P3L42" : "Resource methods MUST NOT have more than one parameter that is not annotated with one of the above listed annotations.",
	"P3L43" : "3.3.3 Tipo de Retorno",
	"P3L44" : "Resource methods MAY return void, Response, GenericEntity, or another Java type, these return types are mapped to a response entity body as follows:",
	"P3L45" : "void Results in an empty entity body with a 204 status code.",
	"P3L46" : "Response Results in an entity body mapped from the entity property of the Response with the status code specified by the status property of the Response. A null return value results in a 204 status code. If the status property of the Response is not set: a 200 status code is used for a non-null entity property and a 204 status code is used if the entity property is null. ",
	"P3L47" : "GenericEntity Results in an entity body mapped from the Entity property of the GenericEntity. If the return value is not null a 200 status code is used, a null return value results in a 204 status code.",
	"P3L48" : "Other Results in an entity body mapped from the class of the returned instance. If the return value is not null a 200 status code is used, a null return value results in a 204 status code.",
	"P3L49" : "Methods that need to provide additional metadata with a response should return an instance of Response, the ResponseBuilder class provides a convenient way to create a Response instance using a builder pattern. ",
	"P3L50" : "Conversion between a Java object and an entity body is the responsibility of an entity provider, see section 4.2. The return type of a resource method and the type of the returned instance are used to determine the raw type and generic type supplied to the isWritable method of MessageBodyWriteras follows:",
	"P3T1L1" : "Tipo de Retorno",
	"P3T1L2" : "Instância Retornada",
	"P3T1L3" : "Raw Type",
	"P3T1L4" : "Tipo Genérico",
	"P3T1L5" : "GenericEntity",
	"P3T1L6" : "GenericEntity or subclass",
	"P3T1L7" : "RawType property",
	"P3T1L8" : "Type property",
	"P3T1L9" : "Response",
	"P3T1L10" : "GenericEntity or subclass",
	"P3T1L11" : "RawType property",
	"P3T1L12" : "Type property",
	"P3T1L13" : "Response",
	"P3T1L14" : "Object or subclass",
	"P3T1L15" : "Class of instance",
	"P3T1L16" : "Class of instance",
	"P3T1L17" : "Outro",
	"P3T1L18" : "Tipo de retorno ou subclasse",
	"P3T1L19" : "Class of instance",
	"P3T1L20" : "Generic type of return type",
	"P3L51" : "Table 3.1: Determining raw and generic types of return values",
	"P3L52" : "To illustrate the above consider a method that always returns an instance of ArrayList<String> either directly or wrapped in some combination of Response and GenericEntity. The resulting raw and generic types are shown below. ",
	"P3T1L21" : "Tipo de Retorno",
	"P3T1L22" : "Instância Retornada",
	"P3T1L23" : "Raw Type",
	"P3T1L24" : "Tipo Genérico",
	"P3T1L25" : "GenericEntity",
	"P3T1L26" : "GenericEntity<List<String>>",
	"P3T1L27" : "ArrayList<?>",
	"P3T1L28" : "List<String>",
	"P3T1L29" : "Response",
	"P3T1L30" : "GenericEntity<List<String>>",
	"P3T1L31" : "ArrayList<?>",
	"P3T1L32" : "List<String>",
	"P3T1L33" : "Response",
	"P3T1L34" : "ArrayList<String>",
	"P3T1L35" : "ArrayList<?>",
	"P3T1L36" : "ArrayList<?>",
	"P3T1L37" : "List<String>",
	"P3T1L38" : "ArrayList<String>",
	"P3T1L39" : "ArrayList<?>",
	"P3T1L40" : "List<String>",
	"P3L53" : "Tabela 3.2: Example raw and generic types of return values",
	"P3L54" : "3.3.4 Exceções",
	"P3L55" : "A resource method, sub-resource method or sub-resource locator may throw any checked or unchecked exception. An implementation MUST catch all exceptions and process them as follows:",
	"P3L56" : "Instances of WebApplicationException MUST be mapped to a response as follows. If the response property of the exception does not contain an entity and an exception mapping provider (see section 4.4) is available for WebApplicationException an implementation MUST use the provider to create a new Response instance, otherwise the response property is used directly. The resulting Response instance is then processed according to section 3.3.3.",
	"P3L57" : "If an exception mapping provider (see section 4.4) is available for the exception or one of its super classes, an implementation MUST use the provider whose generic type is the nearest superclass of the exception to create a Response instance that is then processed according to section 3.3.3. If the exception mapping provider throws an exception while creating a Response then return a server error (status code 500) response to the client.",
	"P3L58" : "Unchecked exceptions and errors MUST be re-thrown and allowed to propagate to the underlying container.",
	"P3L59" : "Checked exceptions and throwables that cannot be thrown directly MUST be wrapped in a container specific exception that is then thrown and allowed to propagate to the underlying container. Servlet based implementations MUST use ServletException as the wrapper. JAX-WS Provider-based implementations MUST use WebServiceException as the wrapper.",
	"P3L60" : "Note: Items 3 and 4 allow existing container facilities (e.g. a Servlet filter or error pages) to be used to handle the error if desired.",
	"P3L61" : "3.3.5 HEAD and OPTIONS",
	"P3L62" : "HEAD and OPTIONS requests receive additional automated support. On receipt of a HEAD request an implementation MUST either:",
	"P3L63" : "Call a method annotated with a request method designator for HEAD or, if none present,",
	"P3L64" : "Call a method annotated with a request method designator for GET and discard any returned entity.",
	"P3L65" : "Note that option 2 may result in reduced performance where entity creation is significant.",
	"P3L66" : "On receipt of an OPTIONS request an implementation MUST either:",
	"P3L67" : "Call a method annotated with a request method designator for OPTIONS or, if none present,",
	"P3L68" : "Generate an automatic response using the metadata provided by the JAX-RS annotations on the matching class and its methods.",
	"P3L69" : "3.4 URI Templates",
	"P3L70" : "A root resource class is anchored in URI space using the @Path annotation. The value of the annotation is a relative URI path template whose base URI is provided by the deployment context.",
	"P3L71" : "A URI path template is a string with zero or more embedded parameters that, when values are substituted for all the parameters, is a valid URI[5] path. The Javadoc for the @Path annotation describes their syntax. E.g.:",
	"P3L72" : "In the above example the Widget resource class is identified by the relative URI path widgets/xxx where xxx is the value of the id parameter",
	"P3L73" : "Note: Because ‘{’and ‘}’ are not part of either the reserved or unreserved productions of URI[5] they will not appear in a valid URI. ",
	"P3L74" : "The value of the annotation is automatically encoded, e.g. the following two lines are equivalent:",
	"P3L75" : "Template parameters can optionally specify the regular expression used to match their values. The default value matches any text and terminates at the end of a path segment but other values can be used to alter this behavior, e.g.: ",
	"P3L76" : "In the above example the Widget resource class will be matched for any request whose path starts with widgets and contains at least one more path segment; the value of the path parameter will be the request path following widgets. E.g. given the request path widgets/small/a the value of path would be small/a.",
	"P3L77" : "3.4.1 Sub Resources",
	"P3L78" : "Methods of a resource class that are annotated with @Path are either sub-resource methods or sub-resource locators. Sub-resource methods handle a HTTP request directly whilst sub-resource locators return an object that will handle a HTTP request. The presence or absence of a request method designator (e.g. @GET) differentiates between the two: ",
	"P3L79" : "Present Such methods, known as sub-resource methods, are treated like a normal resource method (see section 3.3) except the method is only invoked for request URIs that match a URI template created by concatenating the URI template of the resource class with the URI template of the method 2.",
	"P3L80" : "Absent Such methods, known as sub-resource locators, are used to dynamically resolve the object that will handle the request. Any returned object is treated as a resource class instance and used to either handle the request or to further resolve the object that will handle the request, see 3.7 for further details. An implementation MUST dynamically determine the class of object returned rather than relying on the static sub-resource locator return type since the returned instance may be a subclass of the declared type with potentially different annotations, see section 3.6 for rules on annotation inheritance. Subresource locators may have all the same parameters as a normal resource method (see section 3.3) except that they MUST NOT have an entity parameter.",
	"P3L81" : "The following example illustrates the difference:",
	"P3L82" : "In the above a GET request for the widgets/offers resource is handled directly by the getDiscounted sub-resource method of the resource class WidgetsResource whereas a GET request for widgets/xxx is handled by the getDetails method of the WidgetResource resource class",
	"P3L83" : "Note: A set of sub-resource methods annotated with the same URI template value are functionally equivalent to a similarly annotated sub-resource locator that returns an instance of a resource class with the same set of resource methods. ",
	"P3L84" : "3.5 Declaring Media Type Capabilities",
	"P3L85" : "Application classes can declare the supported request and response media types using the @Consumes and @Produces annotations respectively. These annotations MAY be applied to a resource method, a resource class, or to an entity provider (see section 4.2.3). Use of these annotations on a resource method overrides any on the resource class or on an entity provider for a method argument or return type. In the absence of either of these annotations, support for any media type (“*/*”) is assumed. ",
	"P3L86" : "The following example illustrates the use of these annotations:",
	"P3L87" : "In the above:",
	"P3L88" : "The getAsXML resource method will be called for GET requests that specify a response media type of application/widgets+xml. It returns a Widgets instance that will be mapped to that format using the WidgetsProvider class (see section 4.2 for more information on MessageBodyWriter).",
	"P3L89" : "The getAsHtml resource method will be called for GET requests that specify a response media type of text/html. It returns a String containing text/html that will be written using the default implementation of MessageBodyWriter<String>.",
	"P3L90" : "The addWidget resource method will be called for POST requests that contain an entity of the media type application/widgets+xml. The value of the widget parameter will be mapped from the request entity using the WidgetProvider class (see section 4.2 for more information on MessageBodyReader). ",
	"P3L91" : "An implementation MUST NOT invoke a method whose effective value of @Produces does not match the request Accept header. An implementation MUST NOT invoke a method whose effective value of @Consumes does not match the request Content-Type header.",
	"P3L92" : "3.6 Annotation Inheritance",
	"P3L93" : "JAX-RS annotations MAY be used on the methods of a super-class or an implemented interface. Such annotations are inherited by a corresponding sub-class or implementation class method provided that method does not have any of its own JAX-RS annotations. Annotations on a super-class take precedence over those on an implemented interface. If a subclass or implementation method has any JAX-RS annotations then all of the annotations on the super class or interface method are ignored. E.g.:",
	"P3L94" : "In the above, ActivityLog.getFeed inherits the @GET and @Produces annotations from the interface. Conversely:",
	"P3L95" : "In the above, the @GET annotation on ReadOnlyAtomFeed.getFeed is not inherited by ActivityLog.getFeed and it would require its own request method designator since it redefines the @Produces annotation.",
	"P3L96" : "3.7 Matching Requests to Resource Methods",
	"P3L97" : "This section describes how a request is matched to a resource class and method. Implementations are not required to use the algorithm as written but MUST produce results equivalent to those produced by the algorithm.",
	"P3L98" : "3.7.1 Request Preprocessing",
	"P3L99" : "Prior to matching, request URIs are normalized3 by following the rules for case, path segment, and percent encoding normalization described in section 6.2.2 of RFC 3986[5]. The normalized request URI MUST be reflected in the URIs obtained from an injected UriInfo.",
	"P3L100" : "3.7.2 Request Matching",
	"P3L101" : "A request is matched to the corresponding resource method or sub-resource method by comparing the normalized request URI (see section 3.7.1), the media type of any request entity, and the requested response entity format to the metadata annotations on the resource classes and their methods. If no matching resource method or sub-resource method can be found then an appropriate error response is returned. Matching of requests to resource methods proceeds in three stages as follows:",
	"P3L102" : "Identify the root resource class:",
	"P3L103" : "Set U = request URI path, C = {root resource classes}, E = {}",
	"P3L104" : "For each class in C add a regular expression (computed using the function R(A) described in section 3.7.3) to E as follows: ",
	"P3L105" : "Add R(Tclass) where Tclass is the URI path template specified for the class. ",
	"P3L106" : "Filter E by matching each member against U as follows: ",
	"P3L107" : "Remove members that do not match U. ",
	"P3L108" : "Remove members for which the final regular expression capturing group (henceforth simply referred to as a capturing group) value is neither empty nor ‘/’ and the class associated with R(Tclass) had no sub-resource methods or locators. ",
	"P3L109" : "If E is empty then no matching resource can be found, the algorithm terminates and an implementation MUST generate a WebApplicationException with a not found response (HTTP 404 status) and no entity. The exception MUST be processed as described in section 3.3.4.",
	"P3L110" : "Sort E using the number of literal characters in each member as the primary key (descending order), the number of capturing groups as a secondary key (descending order) and the number of capturing groups with non-default regular expressions (i.e. not ‘([ˆ/]+?)’) as the tertiary key (descending order). ",
	"P3L111" : "Set Rmatch to be the first member of E, set U to be the value of the final capturing group of Rmatch when matched against U, and instantiate an object O of the associated class.",
	"P3L112" : "Obtain the object that will handle the request and a set of candidate methods:",
	"P3L113" : "If U is null or ‘/’, set M = {resource methods of O (excluding sub resource methods)} and go to step 3",
	"P3L114" : "Set C = class of O, E = {} ",
	"P3L115" : "For class C add regular expressions to E for each sub-resource method and locator as follows:",
	"P3L116" : "For each sub-resource method, add R(Tmethod) where Tmethod is the URI path template of the sub-resource method.",
	"P3L117" : "For each sub-resource locator, add R(Tlocator) where Tlocator is the URI path template of the sub-resource locator.",
	"P3L118" : "Filter E by matching each member against U as follows: ",
	"P3L119" : "Remove members that do not match U. ",
	"P3L120" : "Remove members derived from Tmethod (those added in step 2(c)i) for which the final capturing group value is neither empty nor ‘/’.",
	"P3L121" : "If E is empty then no matching resource can be found, the algorithm terminates and an implementation MUST generate a WebApplicationException with a not found response (HTTP 404 status) and no entity. The exception MUST be processed as described in section 3.3.4.",
	"P3L122" : "Sort E using the number of literal characters in each member as the primary key (descending order), the number of capturing groups as a secondary key (descending order), the number of capturing groups with non-default regular expressions (i.e. not ‘([ˆ/]+?)’) as the tertiary key (descending order), and the source of each member as quaternary key sorting those derived from Tmethod ahead of those derived from Tlocator. ",
	"P3L123" : "Set Rmatch to be the first member of E",
	"P3L124" : "If Rmatch was derived from Tmethod, then set M = {subresource methods of O where R(Tmethod) = Rmatch} and go to step 3.",
	"P3L125" : "Set U to be the value of the final capturing group of R(Tmatch) when matched against U, invoke the sub-resource locator method of O and set O to the value returned from that method.",
	"P3L126" : "Go to step 2a.",
	"P3L127" : "Identify the method that will handle the request:",
	"P3L128" : "Filter M by removing members that do not meet the following criteria: ",
	"P3L129" : "The request method is supported. If no methods support the request method an implementation MUST generate a WebApplicationException with a method not allowed response (HTTP 405 status) and no entity. The exception MUST be processed as described in section 3.3.4. Note the additional support for HEAD and OPTIONS described in section 3.3.5. ",
	"P3L130" : "The media type of the request entity body (if any) is a supported input data format (see section 3.5). If no methods support the media type of the request entity body an implementation MUST generate a WebApplicationException with an unsupported media type response (HTTP 415 status) and no entity. The exception MUST be processed as described in section 3.3.4.",
	"P3L131" : "At least one of the acceptable response entity body media types is a supported output data format (see section 3.5). If no methods support one of the acceptable response entity body media types an implementation MUST generate a WebApplicationException with a not acceptable response (HTTP 406 status) and no entity. The exception MUST be processed as described in section 3.3.4. ",
	"P3L132" : "Sort M in descending order as follows: ",
	"P3L133" : "The primary key is the media type of input data. Methods whose @Consumes value is the best match for the media type of the request are sorted first. ",
	"P3L134" : "The secondary key is the @Produces value. Methods whose value of @Produces best matches the value of the request accept header are sorted first.",
	"P3L135" : "Determining the best matching media types follows the general rule: n/m > n/* > */*, i.e. a method that explicitly consumes the request media type or produces one of the requested media types is sorted before a method that consumes or produces */*. Quality parameter values in the accept header are also considered such that methods that produce media types with a higher acceptable q-value are sorted ahead of those with a lower acceptable q-value (i.e. n/m;q=1.0 > n/m;q=0.7) - see section 14.1 of [4] for more details.",
	"P3L136" : "The request is dispatched to the first Java method in the set.",
	"P3L137" : "3.7.3 Converting URI Templates to Regular Expressions",
	"P3L138" : "The function R(A) converts a URI path template annotation A into a regular expression as follows: ",
	"P3L139" : "URI encode the template, ignoring URI template variable specifications.",
	"P3L140" : "Escape any regular expression characters in the URI template, again ignoring URI template variable specifications. ",
	"P3L141" : "Replace each URI template variable with a capturing group containing the specified regular expression or ‘([ˆ/]+?)’ if no regular expression is specified.",
	"P3L142" : "If the resulting string ends with ‘/’ then remove the final character.",
	"P3L143" : "Append ‘(/.*)?’ to the result.",
	"P3L144" : "Note that the above renders the name of template variables irrelevant for template matching purposes. However, implementations will need to retain template variable names in order to facilitate the extraction of template variable values via @PathParam or UriInfo.getPathParameters.",
	"P3L145" : "3.8 Determining the MediaType of Responses",
	"P3L146" : "In many cases it is not possible to statically determine the media type of a response. The following algorithm is used to determine the response media type, Mselected, at run time:",
	"P3L147" : "If the method returns an instance of Response whose metadata includes the response media type (Mspecified) then set Mselected = Mspecified, finish.",
	"P3L148" : "Gather the set of producible media types P:",
	"P3L149" : "If the method is annotated with @Produces, set P = {V (method)} where V (t) represents the values of @Produces on the specified target t.",
	"P3L150" : "Else if the class is annotated with @Produces, set P = {V (class)}.",
	"P3L151" : "Else set P = {V (writers)} where ‘writers’ is the set of MessageBodyWriter that support the class of the returned entity object.",
	"P3L152" : "If P = {}, set P = {‘*/*’}",
	"P3L153" : "Obtain the acceptable media types A. If A = {}, set A = {‘*/*’}",
	"P3L154" : "Set M = {}. For each member of A, a:",
	"P3L155" : "For each member of P, p: – If a is compatible with p, add S(a, p) to M, where the function S returns the most specific media type of the pair with the q-value of a.",
	"P3L156" : "If M = {} then generate a WebApplicationException with a not acceptable response (HTTP 406 status) and no entity. The exception MUST be processed as described in section 3.3.4. Finish.",
	"P3L157" : "Sort M in descending order, with a primary key of specificity (n/m > n/* > */*) and secondary key of q-value.",
	"P3L158" : "For each member of M, m:",
	"P3L159" : "If m is a concrete type, set Mselected = m, finish.",
	"P3L160" : "If M contains ‘*/*’ or ‘application/*’, set Mselected = ‘application/octet-stream’, finish.",
	"P3L161" : "Generate a WebApplicationException with a not acceptable response (HTTP 406 status) and no entity. The exception MUST be processed as described in section 3.3.4. Finish.",
	"P3L162" : "Note that the above renders a response with a default media type of ‘application/octet-stream’ when a concrete type cannot be determined. It is RECOMMENDED that MessageBodyWriter implementations specify at least one concrete type via @Produces.",

	"P4L1" : "Capítulo 4",
	"P4L2" : "Providers",
	"P4L3" : "The JAX-RS runtime is extended using application-supplied provider classes. A provider is annotated with @Provider and implements one or more interfaces defined by JAX-RS. ",
	"P4L4" : "4.1 Lifecycle and Environment",
	"P4L5" : "By default a single instance of each provider class is instantiated for each JAX-RS application. First the constructor (see section 4.1.1) is called, then any requested dependencies are injected (see chapter 5), then the appropriate provider methods may be called multiple times (simultaneously), and finally the object is made available for garbage collection. Section 5.2.5 describes how a provider obtains access to other providers via dependency injection. ",
	"P4L6" : "An implementation MAY offer other provider lifecycles, mechanisms for specifying these are outside the scope of this specification. E.g. an implementation based on an inversion-of-control framework may support all of the lifecycle options provided by that framework. ",
	"P4L7" : "4.1.1 Construtores",
	"P4L8" : "Provider classes are instantiated by the JAX-RS runtime and MUST have a public constructor for which the JAX-RS runtime can provide all parameter values. Note that a zero argument constructor is permissible under this rule. ",
	"P4L9" : "A public constructor MAY include parameters annotated with @Context- chapter 5 defines the parameter types permitted for this annotation. Since providers may be created outside the scope of a particular request, only deployment-specific properties may be available from injected interfaces at construction time - request- specific properties are available when a provider method is called. If more than one public constructor can be used then an implementation MUST use the one with the most parameters. Choosing amongst constructors with the same number of parameters is implementation specific, implementations SHOULD generate a warning about such ambiguity. ",
	"P4L10" : "4.2 Entity Providers",
	"P4L11" : "Entity providers supply mapping services between representations and their associated Java types. Entity providers come in two flavors: MessageBodyReader and MessageBodyWriter described below. In the absence of a suitable entity provider, JAX-RS implementations are REQUIRED to use to the JavaBeans Activation Framework[11] to try to obtain a suitable data handler to perform the mapping instead.",
	"P4L12" : "4.2.1 Message Body Reader",
	"P4L13" : "The MessageBodyReader interface defines the contract between the JAX-RS runtime and components that provide mapping services from representations to a corresponding Java type. A class wishing to provide such a service implements the MessageBodyReader interface and is annotated with @Provider.",
	"P4L14" : "The following describes the logical steps taken by a JAX-RS implementation when mapping a request entity body to a Java method parameter: ",
	"P4L15" : "Identify the Java type of the parameter whose value will be mapped from the entity body. Section 3.7 describes how the Java method is chosen. ",
	"P4L16" : "Select the set of MessageBodyReader classes that support the media type of the request, see section 4.2.3.",
	"P4L17" : "Iterate through the selected MessageBodyReader classes and, utilizing the isReadable method of each, choose a MessageBodyReader provider that supports the desired Java type. ",
	"P4L18" : "If step 3 locates a suitable MessageBodyReader then use its readFrom method to map the entity body to the desired Java type. ",
	"P4L19" : "Else if a suitable data handler can be found using the JavaBeans Activation Framework[11] then use it to map the entity body to the desired Java type. ",
	"P4L20" : "Else generate a WebApplicationException that contains an unsupported media type response (HTTP 415 status) and no entity. The exception MUST be processed as described in section 3.3.4.",
	"P4L21" : "A MessageBodyReader.readFrom method MAY throw WebApplicationException. If thrown, the resource method is not invoked and the exception is treated as if it originated from a resource method, see section 3.3.4. ",
	"P4L22" : "4.2.2 Message Body Writer",
	"P4L23" : "The MessageBodyWriter interface defines the contract between the JAX-RS runtime and components that provide mapping services from a Java type to a representation. A class wishing to provide such a service implements the MessageBodyWriter interface and is annotated with @Provider.",
	"P4L24" : "The following describes the logical steps taken by a JAX-RS implementation when mapping a return value to a response entity body: ",
	"P4L25" : "Obtain the object that will be mapped to the response entity body. For a return type of Response or subclasses the object is the value of the entity property, for other return types it is the returned object.",
	"P4L26" : "Determine the media type of the response, see section 3.8.",
	"P4L27" : "Select the set of MessageBodyWriter providers that support (see section 4.2.3) the object and media type of the response entity body.",
	"P4L28" : "Sort the selected MessageBodyWriter providers as described in section 4.2.3.",
	"P4L29" : "Iterate through the sorted MessageBodyWriter providers and, utilizing the isWriteable method of each, choose an MessageBodyWriter that supports the object that will be mapped to the entity body.",
	"P4L30" : "If step 5 locates a suitable MessageBodyWriter then use its writeTo method to map the object to the entity body.",
	"P4L31" : "Else if a suitable data handler can be found using the JavaBeans Activation Framework[11] then use it to map the object to the entity body.",
	"P4L32" : "Else generate a WebApplicationException with an internal server error response (HTTP 500 status) and no entity. The exception MUST be processed as described in section 3.3.4. ",
	"P4L33" : "A MessageBodyWriter.write method MAY throw WebApplicationException. If thrown before the response is committed, the exception is treated as if it originated from a resource method, see section 3.3.4. To avoid an infinite loop, implementations SHOULD NOT attempt to map exceptions thrown during serialization of an response previously mapped from an exception and SHOULD instead simply return a server error (status code 500) response.",
	"P4L34" : "4.2.3 Declaring Media Type Capabilities",
	"P4L35" : "Message body readers and writers MAY restrict the media types they support using the @Consumes and @Produces annotations respectively. The absence of these annotations is equivalent to their inclusion with media type (“*/*”), i.e. absence implies that any media type is supported. An implementation MUST NOT use an entity provider for a media type that is not supported by that provider. ",
	"P4L36" : "When choosing an entity provider an implementation sorts the available providers according to the media types they declare support for. Sorting of media types follows the general rule: x/y < x/* < */*, i.e. a provider that explicitly lists a media types is sorted before a provider that lists */*.",
	"P4L37" : "4.2.4 Standard Entity Providers",
	"P4L38" : "An implementation MUST include pre-packaged MessageBodyReader and MessageBodyWriter implementations for the following Java and media type combinations:",
	"P4L39" : "byte[] All media types (*/*).",
	"P4L40" : "java.lang.String All media types (*/*).",
	"P4L41" : "java.io.InputStream All media types (*/*).",
	"P4L42" : "java.io.Reader All media types (*/*).",
	"P4L43" : "java.io.File All media types (*/*).",
	"P4L44" : "javax.activation.DataSource All media types (*/*).",
	"P4L45" : "javax.xml.transform.Source XML types (text/xml, application/xml and application/*+xml).",
	"P4L46" : "javax.xml.bind.JAXBElement and application-supplied JAXB classes XML media types (text/xml, application/xml and application/*+xml). ",
	"P4L47" : "MultivaluedMap<String,String> Form content (application/x-www-form-urlencoded).",
	"P4L48" : "StreamingOutput All media types (*/*), MessageBodyWriter only.",
	"P4L49" : "The implementation-supplied entity provider(s) for javax.xml.bind.JAXBElement and application supplied JAXB classes MUST use JAXBContext instances provided by application-supplied context resolvers, see section 4.3. If an application does not supply a JAXBContext for a particular type, the implementation-supplied entity provider MUST use its own default context instead",
	"P4L50" : "When writing responses, implementations SHOULD respect application-supplied character set metadata and SHOULD use UTF-8 if a character set is not specified by the application or if the application specifies a character set that is unsupported.",
	"P4L51" : "An implementation MUST support application-provided entity providers and MUST use those in preference to its own pre-packaged providers when either could handle the same request.",
	"P4L52" : "4.2.5 Transfer Encoding",
	"P4L53" : "Transfer encoding for inbound data is handled by a component of the container or the JAX-RS runtime. MessageBodyReader providers always operate on the decoded HTTP entity body rather than directly on the HTTP message body.",
	"P4L54" : "A JAX-RS runtime or container MAY transfer encode outbound data or this MAY be done by application code.",
	"P4L55" : "4.2.6 Content Encoding",
	"P4L56" : "Content encoding is the responsibility of the application. Application-supplied entity providers MAY perform such encoding and manipulate the HTTP headers accordingly.",
	"P4L57" : "4.3 Context Providers",
	"P4L58" : "Context providers supply context to resource classes and other providers. A context provider class implements the ContextResolver<T> interface and is annotated with @Provider. E.g. an application wishing to provide a customized JAXBContext to the default JAXB entity providers would supply a class implementing ContextResolver<JAXBContext>. ",
	"P4L59" : "Context providers MAY return null from the getContext method if they do not wish to provide their context for a particular Java type. E.g. a JAXB context provider may wish to only provide the context for certain JAXB classes. Context providers MAY also manage multiple contexts of the same type keyed to different Java types. ",
	"P4L60" : "4.3.1 Declaring Media Type Capabilities",
	"P4L61" : "Context provider implementations MAY restrict the media types they support using the @Produces annotation. The absence of this annotation is equivalent to its inclusion with media type (“*/*”), i.e. absence implies that any media type is supported.",
	"P4L62" : "When choosing a context provider an implementation sorts the available providers according to the media types they declare support for. Sorting of media types follows the general rule: x/y < x/* < */*, i.e. a provider that explicitly lists a media type is sorted before a provider that lists */*. ",
	"P4L63" : "4.4 Exception Mapping Providers",
	"P4L64" : "When a resource class or provider method throws an exception, the JAX-RS runtime will attempt to map the exception to a suitable HTTP response - see section 3.3.4. An application can supply exception mapping providers to customize this mapping. ",
	"P4L65" : "Exception mapping providers map a checked or runtime exception to an instance of Response. An exception mapping provider implements the ExceptionMapper<T> interface and is annotated with @Provider. When a resource method throws an exception for which there is an exception mapping provider, the matching provider is used to obtain a Response instance. The resulting Response is processed as if the method throwing the exception had instead returned the Response, see section 3.3.3. ",
	"P4L66" : "When choosing an exception mapping provider to map an exception, an implementation MUST use the provider whose generic type is the nearest superclass of the exception. ",

	"P5L1" : "Capítulo 5",
	"P5L2" : "Context",
	"P5L3" : "JAX-RS provides facilities for obtaining and processing information about the application deployment context and the context of individual requests. Such information is available to both root resource classes (see chapter 3) and providers (see chapter 4). This chapter describes these facilities.",
	"P5L4" : "5.1 Concurrency",
	"P5L5" : "Context is specific to a particular request but instances of certain JAX-RS components (providers and resource classes with a lifecycle other than per-request) may need to support multiple concurrent requests. When injecting an instance of one of the types listed in section 5.2, the instance supplied MUST be capable of selecting the correct context for a particular request. Use of a thread-local proxy is a common way to achieve this.",
	"P5L6" : "5.2 Context Types",
	"P5L7" : "This section describes the types of context available to resource classes and providers.",
	"P5L8" : "5.2.1 URIs and URI Templates",
	"P5L9" : "An instance of UriInfo can be injected into a class field or method parameter using the @Context annotation. UriInfo provides both static and dynamic, per-request information, about the components of a request URI. E.g. the following would return the names of any query parameters in a request: ",
	"P5L10" : "Note that the methods of UriInfo provide access to request URI information following the pre-processing described in section 3.7.1.",
	"P5L11" : "5.2.2 Headers",
	"P5L12" : "An instance of HttpHeaders can be injected into a class field or method parameter using the @Context annotation. HttpHeaders provides access to request header information either in map form or via strongly typed convenience methods. E.g. the following would return the names of all the headers in a request:",
	"P5L13" : "Note that the methods of HttpHeaders provide access to request information following the pre-processing described in section 3.7.1.",
	"P5L14" : "Response headers may be provided using the Response class, see 3.3.3 for more details.",
	"P5L15" : "5.2.3 Content Negotiation and Preconditions",
	"P5L16" : "JAX-RS simplifies support for content negotiation and preconditions using the Request interface. An instance of Request can be injected into a class field or method parameter using the @Context annotation. The methods of Request allow a caller to determine the best matching representation variant and to evaluate whether the current state of the resource matches any preconditions in the request. Precondition support methods return a ResponseBuilder that can be returned to the client to inform it that the request preconditions were not met. E.g. the following checks if the current entity tag matches any preconditions in the request before updating the resource:",
	"P5L17" : "The application could also set the content location, expiry date and cache control information into the returned ResponseBuilder before building the response. ",
	"P5L18" : "5.2.4 Security Context",
	"P5L19" : "The SecurityContext interface provides access to information about the security context of the current request. An instance of SecurityContext can be injected into a class field or method parameter using the @Context annotation. The methods of SecurityContext provide access to the current user principle, information about roles assumed by the requester, whether the request arrived over a secure channel and the authentication scheme used.",
	"P5L20" : "5.2.5 Providers",
	"P5L21" : "The Providers interface allows for lookup of provider instances based on a set of search criteria. An instance of Providers can be injected into a class field or method parameter using the @Context annotation. ",
	"P5L22" : "This interface is expected to be primarily of interest to provider authors wishing to use other providers functionality.",

	"P6L1" : "Capítulo 6",
	"P6L2" : "Ambiente",
	"P6L3" : "The container-managed resources available to a JAX-RS root resource class or provider depend on the environment in which it is deployed. Section 5.2 describes the types of context available regardless of container. The following sections describe the additional container-managed resources available to a JAX-RS root resource class or provider deployed in a variety of environments.",
	"P6L4" : "6.1 Servlet Container",
	"P6L5" : "The @Context annotation can be used to indicate a dependency on a Servlet-defined resource. A Servlet based implementation MUST support injection of the following Servlet-defined types: ServletConfig, ServletContext, HttpServletRequest and HttpServletResponse. ",
	"P6L6" : "An injected HttpServletRequest allows a resource method to stream the contents of a request entity. If the resource method has a parameter whose value is derived from the request entity then the stream will have already been consumed and an attempt to access it MAY result in an exception. ",
	"P6L7" : "An injected HttpServletResponse allows a resource method to commit the HTTP response prior to returning. An implementation MUST check the committed status and only process the return value if the response is not yet committed.",
	"P6L8" : "6.2 Java EE Container (Non-normative)",
	"P6L9" : "This section describes the additional features anticipated to be available to a JAX-RS application hosted in a Java EE 6 container. It is planned that JAX-RS will be finalized prior to Java EE 6 so the contents of this section are preliminary and subject to change. Nothing in this section should be considered a conformance requirement.",
	"P6L10" : "JAX-RS root resource classes and providers are supplied with the same resource injection capabilities as are provided for a Servlet instance running in a Java EE Web container. In particular the following annotations may be used according to their individual semantics: @Resource, @Resources, @EJB, @EJBs, @WebServiceRef, @WebServiceRefs, @PersistenceContext, @PersistenceContexts, @PersistenceUnit and @PersistenceUnits.",
	"P6L11" : "JAX-RS root resource classes and providers may also make use of the following JSR 250 lifecycle management and security annotations: @PostConstruct, @PreDestroy, @RunAs, @RolesAllowed, @PermitAll, @DenyAll and @DeclareRoles.",
	"P6L12" : "6.3 Other",
	"P6L13" : "Other container technologies MAY specify their own set of injectable resources but MUST, at a minimum, support access to the types of context listed in section 5.2.",

	"P7L1" : "Capítulo 7",
	"P7L2" : "Runtime Delegate",
	"P7L3" : "RuntimeDelegate is an abstract factory class that provides various methods for the creation of objects that implement JAX-RS APIs. These methods are designed for use by other JAX-RS API classes and are not intended to be called directly by applications. RuntimeDelegate allows the standard JAX-RS API classes to use different JAX-RS implementations without any code changes.",
	"P7L4" : "An implementation of JAX-RS MUST provide a concrete subclass of RuntimeDelegate. Using the supplied RuntimeDelegate this can be provided to JAX-RS in one of two ways: ",
	"P7L5" : "An instance of RuntimeDelegate can be instantiated and injected using its static method setInstance. In this case the implementation is responsible for creating the instance; this option is intended for use with implementations based on IoC frameworks.",
	"P7L6" : "The class to be used can be configured, see section 7.1. In this case JAX-RS is responsible for instantiating an instance of the class and the configured class MUST have a public constructor which takes no arguments.",
	"P7L7" : "Note that an implementation MAY supply an alternate implementation of the RuntimeDelegate API class (provided it passes the TCK signature test and behaves according to the specification) that supports alternate means of locating a concrete subclass. ",
	"P7L8" : "A JAX-RS implementation may rely on a particular implementation of RuntimeDelegate being used applications SHOULD NOT override the supplied RuntimeDelegate instance with an application-supplied alternative and doing so may cause unexpected problems.",
	"P7L9" : "7.1 Configuration",
	"P7L10" : "If not supplied by injection, the supplied RuntimeDelegate API class obtains the concrete implementation class using the following algorithm. The steps listed below are performed in sequence and, at each step, at most one candidate implementation class name will be produced. The implementation will then attempt to load the class with the given class name using the current context class loader or, missing one, the java.lang.Class.forName(String) method. As soon as a step results in an implementation class being successfully loaded, the algorithm terminates.",
	"P7L11" : "If a resource with the name of META-INF/services/javax.ws.rs.ext.RuntimeDelegate exists, then its first line, if present, is used as the UTF-8 encoded name of the implementation class. 2",
	"P7L12" : "If the ${java.home}/lib/jaxrs.properties file exists and it is readable by the java.util.Properties.load(InputStream) method and it contains an entry whose key is javax.ws.rs.ext.RuntimeDelegate, then the value of that entry is used as the name of the implementation class.",
	"P7L13" : "If a system property with the name javax.ws.rs.ext.RuntimeDelegate is defined, then its value is used as the name of the implementation class.",
	"P7L14" : "Finally, a default implementation class name is used.",

	"PaaL1" : "Apêndice A",
	"PaaL2" : "Sumário de Anotações",
	"PaaT1L1" : "Annotation",
	"PaaT1L2" : "Target",
	"PaaT1L3" : "Description",
	"PaaT1L4" : "Consumes",
	"PaaT1L5" : "Type or method",
	"PaaT1L6" : "Specifies a list of media types that can be consumed.",
	"PaaT1L7" : "Produces",
	"PaaT1L8" : "Type or method",
	"PaaT1L9" : "Specifies a list of media types that can be produced.",
	"PaaT1L10" : "GET",
	"PaaT1L11" : "Method",
	"PaaT1L12" : "Specifies that the annotated method handles HTTP GET requests.",
	"PaaT1L13" : "POST",
	"PaaT1L14" : "Method",
	"PaaT1L15" : "Specifies that the annotated method handles HTTP POST requests.",
	"PaaT1L16" : "PUT",
	"PaaT1L17" : "Method",
	"PaaT1L18" : "Specifies that the annotated method handles HTTP PUT requests.",
	"PaaT1L19" : "DELETE",
	"PaaT1L20" : "Method",
	"PaaT1L21" : "Specifies that the annotated method handles HTTP DELETE requests.",
	"PaaT1L22" : "HEAD",
	"PaaT1L23" : "Method",
	"PaaT1L24" : "Specifies that the annotated method handles HTTP HEAD requests. Note that HEAD may be automatically handled, see section 3.3.5.",
	"PaaT1L25" : "Path",
	"PaaT1L26" : "Type or method",
	"PaaT1L27" : "Specifies a relative path for a resource. When used on a class this annotation identifies that class as a root resource. When used on a method this annotation identifies a sub-resource method or locator.",
	"PaaT1L28" : "PathParam",
	"PaaT1L29" : "Parameter, field or method",
	"PaaT1L30" : "Specifies that the value of a method parameter, class field, or bean property is to be extracted from the request URI path. The value of the annotation identifies the name of a URI template parameter.",
	"PaaT1L31" : "QueryParam",
	"PaaT1L32" : "Parameter, field or method",
	"PaaT1L33" : "Specifies that the value of a method parameter, class field, or bean property is to be extracted from a URI query parameter. The value of the annotation identifies the name of a query parameter.",
	"PaaT1L34" : "FormParam",
	"PaaT1L35" : "Parameter, field or method",
	"PaaT1L36" : "Specifies that the value of a method parameter is to be extracted from a form parameter in a request entity body. The value of the annotation identifies the name of a form parameter. Note that whilst the annotation target allows use on fields and methods, the specification only requires support for use on resource method parameters.",
	"PaaT1L37" : "MatrixParam",
	"PaaT1L38" : "Parameter, field or method",
	"PaaT1L39" : "Specifies that the value of a method parameter, class field, or bean property is to be extracted from a URI matrix parameter. The value of the annotation identifies the name of a matrix parameter.",
	"PaaT1L40" : "CookieParam",
	"PaaT1L41" : "Parameter, field or method",
	"PaaT1L42" : "Specifies that the value of a method parameter, class field, or bean property is to be extracted from a HTTP cookie. The value of the annotation identifies the name of a the cookie.",
	"PaaT1L43" : "HeaderParam",
	"PaaT1L44" : "Parameter, field or method",
	"PaaT1L45" : "Specifies that the value of a method parameter, class field, or bean property is to be extracted from a HTTP header. The value of the annotation identifies the name of a HTTP header",
	"PaaT1L46" : "Encoded",
	"PaaT1L47" : "Type, constructor, method, field or parameter",
	"PaaT1L48" : "Disables automatic URI decoding for path, query, form and matrix parameters.",
	"PaaT1L49" : "DefaultValue",
	"PaaT1L50" : "Parameter, field or method",
	"PaaT1L51" : "Specifies a default value for a field, property or method parameter annotated with @QueryParam, @MatrixParam, @CookieParam, @FormParam or @HeaderParam. The specified value will be used if the corresponding query or matrix parameter is not present in the request URI, if the corresponding form parameter is not in the request entity body, or if the corresponding HTTP header is not included in the request.",
	"PaaT1L52" : "Context",
	"PaaT1L53" : "Field, method or parameter",
	"PaaT1L54" : "Identifies an injection target for one of the types listed in section 5.2 or the applicable section of chapter 6.",
	"PaaT1L55" : "HttpMethod",
	"PaaT1L56" : "Annotation",
	"PaaT1L57" : "Specifies the HTTP method for a request method designator annotation.",
	"PaaT1L58" : "Provider",
	"PaaT1L59" : "Type",
	"PaaT1L60" : "Specifies that the annotated class implements a JAX-RS extension interface.",

	"PabL1" : "Apêndice B",
	"PabL2" : "HTTP Header Support",
	"PabL3" : "The following table lists HTTP headers that are directly supported, either automatically by a JAX-RS implementation runtime or by an application using the JAX-RS API. Any request header may be obtained using HttpHeaders, see section 5.2.2; response headers not listed here may set using the ResponseBuilder.header method.",
	"PabT1L1" : "Header",
	"PabT1L2" : "Description",
	"PabT1L3" : "Accept",
	"PabT1L4" : "Used by runtime when selecting a resource method, compared to value of @Produces annotation, see section 3.5.",
	"PabT1L5" : "Accept-Charset",
	"PabT1L6" : "Processed by runtime if application uses Request.selectVariant method, see section 5.2.3.",
	"PabT1L7" : "Accept-Encoding",
	"PabT1L8" : "Processed by runtime if application uses Request.selectVariant method, see section 5.2.3.",
	"PabT1L9" : "Accept-Language",
	"PabT1L10" : "Processed by runtime if application uses Request.selectVariant method, see section 5.2.3.",
	"PabT1L11" : "Allow",
	"PabT1L12" : "Included in automatically generated 405 error responses (see section 3.7.2) and automatically generated responses to OPTIONS requests (see section 3.3.5).",
	"PabT1L13" : "Authorization",
	"PabT1L14" : "Depends on container, information available via SecurityContext, see section 5.2.4.",
	"PabT1L15" : "Cache-Control",
	"PabT1L16" : "See CacheControl class and ResponseBuilder.cacheControl method.",
	"PabT1L17" : "Content-Encoding",
	"PabT1L18" : "Response header set by application using Response.ok or ResponseBuilder.variant.",
	"PabT1L19" : "Content-Language",
	"PabT1L20" : "Response header set by application using Response.ok, ResponseBuilder.language, or ResponseBuilder.variant.",
	"PabT1L21" : "Content-Length",
	"PabT1L22" : "Processed automatically for requests, set automatically in responses if value is provided by the MessageBodyWriter used to serialize the response entity",
	"PabT1L23" : "Content-Type",
	"PabT1L24" : "Request header used by runtime when selecting a resource method, compared to value of @Consumes annotation, see section 3.5. Response header either set by application using Response.ok, ResponseBuilder.type, or ResponseBuilder.variant, or set automatically by runtime (see section 3.8).",
	"PabT1L25" : "Cookie",
	"PabT1L26" : "See Cookie class and HttpHeaders.getCookies method.",
	"PabT1L27" : "Date",
	"PabT1L28" : "Included in responses automatically as per HTTP/1.1.",
	"PabT1L29" : "ETag",
	"PabT1L30" : "See EntityTag class, Response.notModified method and ResponseBuilder.tag method.",
	"PabT1L31" : "Expect",
	"PabT1L32" : "Depends on underlying container.",
	"PabT1L33" : "Expires",
	"PabT1L34" : "Set by application using the ResponseBuilder.expires method.",
	"PabT1L35" : "If-Match",
	"PabT1L36" : "Processed by runtime if application uses corresponding Request.evaluatePreconditions method, see section 5.2.3.",
	"PabT1L37" : "If-Modified-Since",
	"PabT1L38" : "Processed by runtime if application uses corresponding Request.evaluatePreconditions method, see section 5.2.3.",
	"PabT1L39" : "If-None-Match",
	"PabT1L40" : "Processed by runtime if application uses corresponding Request.evaluatePreconditions method, see section 5.2.3.",
	"PabT1L41" : "If-Unmodified-Since",
	"PabT1L42" : "Processed by runtime if application uses corresponding Request.evaluatePreconditions method, see section 5.2.3.",
	"PabT1L43" : "Last-Modified",
	"PabT1L44" : "Set by application using the ResponseBuilder.lastModified method.",
	"PabT1L45" : "Location",
	"PabT1L46" : "Set by application using the applicable Response method or directly using the ResponseBuilder.location method.",
	"PabT1L47" : "Set-Cookie",
	"PabT1L48" : "See NewCookie class and ResponseBuilder.cookie method.",
	"PabT1L49" : "Transfer-Encoding",
	"PabT1L50" : "See section 4.2.5.",
	"PabT1L51" : "Vary",
	"PabT1L52" : "Set by application using Response.notAcceptable method or ResponseBuilder.variants method.",
	"PabT1L53" : "WWW-Authenticate",
	"PabT1L54" : "Depends on container",

	"PacL1" : "Apêndice C",
	"PacL2" : "Change Log",
	"PacL3" : "C.1 Changes Since Proposed Final Draft",
	"PacL4" : "Section 3.7.2: Additional sort criteria so that templates with explicit regexs are sorted ahead of those with the default",
	"PacL5" : "Sections 3.7.2, 3.8, 4.2.3 and 4.3.1: Q-values not used in @Consumes or @Produces.",
	"PacL6" : "Section 4.2.2: Fixed algorithm to refer to section 3.8 instead of restating it. Fixed status code returned when the media type has been determined but an appropriate message body writer cannot be located.",
	"PacL7" : "Chapter 7: Clarify that an implementation can supply an alternate RuntimeDelegate API class.",
	"PacL8" : "C.2 Changes Since Public Review Draft",
	"PacL9" : "Chapter 2: Renamed ApplicationConfig class to Application.",
	"PacL10" : "Chapter 3: UriBuilder reworked to always encode components.",
	"PacL11" : "Sections 3.1.2 and 4.1.1: Added requirement to warn when choice of constructor is ambiguous.",
	"PacL12" : "Section 3.2: FormParam no longer required to be supported on fields or properties.",
	"PacL13" : "Section 3.3.3: Added text describing how to determine raw and generic types from method return type and returned instance. ",
	"PacL14" : "Section 3.4: Template parameters can specify the regular expression that forms their capturing group.",
	"PacL15" : "Section 3.7.1: Make pre-processed URIs available rather than original request URI. Added URI normalization.",
	"PacL16" : "Section 3.7.1: Removed URI-based content negotiation.",
	"PacL17" : "Section 3.7.2: Reorganized the request matching algorithm to remove redundancy and improve readability, no functional change.",
	"PacL18" : "Section 3.7.3: Changes to regular expressions to eliminate edge cases.",
	"PacL19" : "Section 4.2: Added requirement to use JavaBean Activation Framework when no entity provider can be found.",
	"PacL20" : "Section 4.2.4: Require standard JAXB entity providers to use application-supplied JAXB contexts in preference to their own. ",
	"PacL21" : "Section 4.3: Added support for specifying media type capabilities of context providers.",
	"PacL22" : "Section 5.2: Removed ContextResolver from list of injectable resources.",
	"PacL23" : "Section 5.2.5: Changed name to Providers, removed entity provider-specific text to reflect more generic capabilities. ",
	"PacL24" : "Chapter B: New appendix describing where particular HTTP headers are supported.",

	"PbL1" : "Bibliografia",
	"PbL2" : "[1] R. Fielding. Architectural Styles and the Design of Network-based Software Architectures. Ph.d dissertation, University of California, Irvine, 2000. See http://roy.gbiv.com/pubs/dissertation/top.htm.",
	"PbL3" : "[2] REST Wiki. Web site. See http://rest.blueoxen.net/cgi-bin/wiki.pl.",
	"PbL4" : "[3] Representational State Transfer. Web site, Wikipedia. See http://en.wikipedia.org/wiki/Representational State Transfer",
	"PbL5" : "[4] R. Fielding, J. Gettys, J. C. Mogul, H. Frystyk, and T. Berners-Lee. RFC 2616: Hypertext Transfer Protocol – HTTP/1.1. RFC, IETF, January 1997. See http://www.ietf.org/rfc/rfc2616.txt.",
	"PbL6" : "[5] T. Berners-Lee, R. Fielding, and L. Masinter. RFC 3986: Uniform Resource Identifier (URI): Generic Syntax. RFC, IETF, January 2005. See http://www.ietf.org/rfc/rfc3986.txt. ",
	"PbL7" : "[6] L. Dusseault. RFC 4918: HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV). RFC, IETF, June 2007. See http://www.ietf.org/rfc/rfc4918.txt. ",
	"PbL8" : "[7] J.C. Gregorio and B. de hOra. The Atom Publishing Protocol. Internet Draft, IETF, March 2007. See http://bitworking.org/projects/atom/draft-ietf-atompub-protocol-14.html. ",
	"PbL9" : "[8] G. Murray. Java Servlet Specification Version 2.5. JSR, JCP, October 2006. See http://java.sun.com/products/servlet.",
	"PbL10" : "[9] R. Chinnici, M. Hadley, and R. Mordani. Java API for XML Web Services. JSR, JCP, August 2005. See http://jcp.org/en/jsr/detail?id=224. ",
	"PbL11" : "[10] S. Bradner. RFC 2119: Keywords for use in RFCs to Indicate Requirement Levels. RFC, IETF, March 1997. See http://www.ietf.org/rfc/rfc2119.txt. ",
	"PbL12" : "[11] Bill Shannon. JavaBeans Activation Framework. JSR, JCP, May 2006. See http://jcp.org/en/jsr/detail?id=925. "
}
